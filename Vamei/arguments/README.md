## Python进阶04: 函数的参数对应

我们已经接触过函数(function)的参数(arguments)传递。当时我们根据位置，传递对应的参数。我们将接触更多的参数传递方式:[Example1](arguments1.py)
```
def f(a,b,c):
    return a+b+c

print(f(1,2,3))
```
在调用f时，1，2，3根据位置分别传递给了a,b,c。

### 关键字传递
有些情况下，用位置传递会感觉比较死板。**关键字(keyword)传递是根据每个参数的名字传递参数**。关键字并不用遵守位置的对应关系。依然沿用上面f的定义，更改调用方式：[Example2](arguments2.py)
```
print(f(c=3,b=2,a=1))
```

关键字传递可以和位置传递混用。但位置参数要出现在关键字参数之前：
```
print(f(1,c=3,b=2))
```

### 参数默认值
在**定义函数**的时候，使用形如a=19的方式，可以给参数赋予默认值(default)。如果该参数最终没有被传递值，将使用该默认值:[Example3](arguments3.py)
```
def f(a,b,c=10):
    return a+b+c

print(f(3,2))
print(f(3,2,1))
```
* 在第一次调用函数f时， 我们并没有足够的值，c没有被赋值，c将使用默认值10.
* 第二次调用函数的时候，c被赋值为1，不再使用默认值。

### 包裹传递
在定义函数时，我们有时候并不知道调用的时候会传递多少个参数。这时候，包裹(packing)位置参数，或者包裹关键字参数，来进行参数传递，会非常有用.

#### 包裹位置传递: [Example4](arguments4.py)
```
def func(*name):
    print type(name)
    print name

func(1,4,6)
func(5,6,7,1,2,3)
```
两次调用，尽管参数个数不同，都基于同一个func定义。在func的参数表中，**所有的参数被name收集，根据位置合并成一个元组(tuple)**，这就是包裹位置传递。

为了提醒Python参数，name是包裹位置传递所用的元组名，在定义func时，**在name前加*号**。

#### 包裹关键字传递: [Example5](arguments5.py)
```
def func(**dict):
    print type(dict)
    print dict

func(a=1,b=9)
func(m=2,n=1,c=11)
```
与上面一个例子类似，dict是一个字典，收集所有的关键字，传递给函数func。**为了提醒Python，参数dict是包裹关键字传递所用的字典，在dict前加****。

包裹传递的关键在于定义函数时，在相应元组或字典前加*或**。

### 解包裹
*和**，也可以在调用的时候使用，即解包裹(unpacking): [Example6](arguments6.py)
```
def func(a,b,c):
    print a,b,c

args = (1,3,4)
func(*args)
```
在这个例子中，所谓的解包裹，就是在传递tuple时，让tuple的每一个元素对应一个位置参数。在调用func时使用*，是为了提醒Python：我想要把args拆成分散的三个元素，分别传递给a,b,c。（设想一下在调用func时，args前面没有*会是什么后果？）

相应的，也存在对词典的解包裹，使用相同的func定义: [Example7](arguments7.py)
```
dict = {'a':1,'b':2,'c':3}
func(**dict)
```
在传递词典dict时，让词典的每个键值对作为一个关键字传递给func。

### 混合
在定义或者调用参数时，参数的几种传递方式可以混合。但在过程中要小心前后顺序。基本原则是，先位置，再关键字，再包裹位置，再包裹关键字，并且根据上面所说的原理细细分辨。

**注意：请注意定义时和调用时的区分。包裹和解包裹并不是相反操作，是两个相对独立的过程。**

